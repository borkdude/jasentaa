<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Worked Example #2</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><script>

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-39680853-9', 'auto');
  ga('send', 'pageview');

</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Jasentaa</span> <span class="project-version">0.2.5</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="worked-example-1.html"><div class="inner"><span>Worked Example #1</span></div></a></li><li class="depth-1  current"><a href="worked-example-2.html"><div class="inner"><span>Worked Example #2</span></div></a></li><li class="depth-1 "><a href="further-examples.html"><div class="inner"><span>Further examples &amp; implementations</span></div></a></li><li class="depth-1 "><a href="references.html"><div class="inner"><span>References</span></div></a></li><li class="depth-1 "><a href="LICENSE.html"><div class="inner"><span>The MIT License (MIT)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jasentaa</span></div></div></li><li class="depth-2 branch"><a href="jasentaa.collections.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>collections</span></div></a></li><li class="depth-2 branch"><a href="jasentaa.monad.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>monad</span></div></a></li><li class="depth-2"><a href="jasentaa.parser.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parser</span></div></a></li><li class="depth-3 branch"><a href="jasentaa.parser.basic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>basic</span></div></a></li><li class="depth-3"><a href="jasentaa.parser.combinators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>combinators</span></div></a></li><li class="depth-2"><a href="jasentaa.position.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>position</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#worked-example-2" name="worked-example-2"></a>Worked Example #2</h1>
<p>The previous example yielded a resulting data structure which corresponded to the parsed input. There is no reason why the result cannot be evaluated as part of the parsing process. <strong>Graham Hutton</strong> and <strong>Erik Meijer</strong> presented a simple integer calculator in <a href="http://www.cs.uwyo.edu/~jlc/courses/3015/parser_pearl.pdf">Functional Pearls: <em>Monadic Parsing in Haskell</em></a> which does exactly this.</p>
<p>Considering a standard grammar for arithmetic expressions built up from single digits using the operators +, -, * and /, together with parentheses:</p>
<ul>
  <li><em><strong>expr</strong> ::= expr addop term | term</em></li>
  <li><em><strong>term</strong> ::= term mulop factor | factor</em></li>
  <li><em><strong>factor</strong> ::= digit | ( expr )</em></li>
  <li><em><strong>digit</strong> ::= 0 | 1 | … | 9</em></li>
  <li><em><strong>addop</strong> ::= + | -</em></li>
  <li><em><strong>mulop</strong> ::= * | /</em></li>
</ul>
<p>As per the <em>Haskell</em> implementation, we need to forward declare the <em>expr</em> parser:</p>
<pre><code class="clojure">(ns jasentaa.worked-example-2
  (:require
    [jasentaa.monad :as m]
    [jasentaa.position :refer :all])
    [jasentaa.parser :as p]
    [jasentaa.parser.basic :refer :all]
    [jasentaa.parser.combinators :refer :all]))

(declare expr)
</code></pre>
<p>The <em>digit</em> parser follows the exact same implementation as the Haskell example; A check is made to see if the current input satisfies the <code>digit?</code> predicate, and the returned value is calculated from the ordinal value of the character minus zero’s ordinal.</p>
<pre><code class="clojure">(defn- digit? [^Character c]
  (Character/isDigit c))

(def digit
  (m/do*
    (x &lt;- (token (sat digit?)))
    (m/return (- (byte (strip-location x)) (byte \0)))))
</code></pre>
<p><em>factor</em> is either a single digit or a bracketed-expression:</p>
<pre><code class="clojure">(def factor
  (choice
    digit
    (m/do*
      (symb "(")
      (n &lt;- (fwd expr))
      (symb ")")
      (m/return n))))
</code></pre>
<p><em>addop</em> and <em>mulop</em> yield a choice of the core function for +, -, * and / respectively. <em>term</em> and <em>expr</em> are then simple <code>chain-left</code> applications as per the declared grammar:</p>
<pre><code class="clojure">(def addop
  (choice
    (m/do*
      (symb "+")
      (m/return +))
    (m/do*
      (symb "-")
      (m/return -))))

(def mulop
  (choice
    (m/do*
      (symb "*")
      (m/return *))
    (m/do*
      (symb "/")
      (m/return /))))

(def term
  (chain-left factor mulop))

(def expr
  (chain-left term addop))
</code></pre>
<p>Testing the example expression yields the expected result:</p>
<pre><code class="clojure">(take 1 (p/apply expr " 1 - 2 * 3 + 4 "))
; =&gt; ([-1, ()])
; i.e. (+ 4 (- 1 (* 2 3)))
</code></pre>
<p><code>chain-left</code> associates from the left, so this expression evaluates as <em>((1 - (2 * 3)) + 4)</em>. <code>chain-right</code> associates from the right, so substituting that would evaluate as <em>(1 - ((2 * 3) + 4))</em>, resulting in -9. Clearly, in both cases, multiplcation binds before addition.</p>
<pre><code class="clojure">(def term'
  (chain-right factor mulop))

(def expr'
  (chain-right term addop))

(take 1 (p/apply expr' " 1 - 2 * 3 + 4 "))
; =&gt; ([-9, ()])
; i.e. (- 1 (+ 4 (* 2 3)))
</code></pre>
<p><em>I can’t immediately think of a scenarion where <code>chain-right</code> would be used over <code>chain-left</code> - postfix notation perhaps? - but other than that…</em></p>
<p>This example is also encapsulated as another <a href="https://github.com/rm-hull/jasentaa/blob/master/test/jasentaa/worked_example_2.clj">test</a>.</p></div></div></div></body></html>